如何简单理解go中的协程，即goroutine？

目前关于goroutine的解释有的不够明确，有的太过于繁琐，本文精简如下，以求尽可能用最少的文字将所理解的goroutine解释清楚。

1，为什么go中会引入协程？

首先明白一点，为什么Linux中是pthread，因为pthread是posix thread的简写。与进程相比，线程虽然更轻量级，在创建、销毁和切换时更快速，但还是需要有不小的开销。尤其是当一个应用程序需要以多线程方式运行时，所需要的开销更大。而这些开销在go进行并发时是不需要的。另外，对于go的gc机制，会造成线程无意义的耗时等待。原因是go运行gc时，要求所有线程都停止，并且要求内存处于抑制状态。此时各线程就需要相互等待。以上两点，体现出了go引入协程机制的必要性。

2，协程如何实现调度？

先看看线程如何实现调度。都知道线程是cpu调度的基本单位，进程是资源分配的基本单位。一般意义上的线程调度分为两种，即n:1和1:1。n:1即多个用户空间线程在一个os线程上循环执行，优点是可以很好的进行上下文切换，缺点是不能利用多核系统的优势。1:1即一个用户线程只匹配一个os线程，优点是可以很好的利用多核系统的优势，缺点是上下文切换麻烦。go采用m:n的调度机制，即在多个cpu上运行多个协程，去获取上述两个模型的优势，避免劣势。缺点是增加了调度系统的复杂性。

